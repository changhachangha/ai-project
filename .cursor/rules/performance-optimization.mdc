---
description:
globs:
alwaysApply: false
---
# Performance Optimization Guidelines

## üöÄ Next.js Performance Configuration

### Build Configuration Reference
- Next.js config: [next.config.ts](mdc:next.config.ts)
- Build output: **Standalone** for optimal deployment
- Image optimization: **Enabled** with remote patterns
- PWA support: **Enabled** with service worker
- Package transpilation: **Configured** for specific libraries

## üéØ CRITICAL PERFORMANCE RULES

### ‚úÖ ALWAYS DO - Performance

1. **Use dynamic imports** - Split code at component boundaries
2. **Implement proper loading states** - Show feedback during async operations
3. **Optimize images** - Use Next.js Image component with proper sizing
4. **Minimize bundle size** - Analyze and remove unnecessary dependencies
5. **Use React.memo** - Prevent unnecessary re-renders
6. **Implement virtualization** - For large lists and tables
7. **Lazy load components** - Load components only when needed
8. **Use proper caching strategies** - Leverage Next.js caching mechanisms
9. **Optimize fonts** - Use Next.js font optimization
10. **Monitor Core Web Vitals** - Track LCP, FID, and CLS metrics

### ‚ùå NEVER DO - Performance

1. **DON'T import entire libraries** - Use tree-shaking friendly imports
2. **DON'T create unnecessary re-renders** - Avoid inline objects and functions
3. **DON'T use large images** - Optimize and compress all images
4. **DON'T block the main thread** - Move heavy computations to web workers
5. **DON'T ignore bundle analysis** - Regularly check bundle size
6. **DON'T use synchronous operations** - Always use async for I/O operations
7. **DON'T create memory leaks** - Clean up event listeners and subscriptions
8. **DON'T use inefficient algorithms** - Optimize data processing logic
9. **DON'T ignore loading states** - Always provide user feedback
10. **DON'T use unoptimized third-party scripts** - Load scripts efficiently

## üß© Code Splitting Patterns

### Dynamic Imports
```typescript
import dynamic from 'next/dynamic';

// Client-only component with loading state
const ClientOnlyComponent = dynamic(() => import('./ClientOnlyComponent'), {
  ssr: false,
  loading: () => (
    <div className="animate-pulse bg-muted h-32 rounded-md" />
  )
});

// Heavy component with code splitting
const HeavyChart = dynamic(() => import('./HeavyChart'), {
  loading: () => (
    <div className="flex items-center justify-center h-64">
      <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary" />
    </div>
  )
});

// Conditional loading
const AdminPanel = dynamic(() => import('./AdminPanel'), {
  ssr: false,
  loading: () => <div>Loading admin panel...</div>
});

// Usage with conditional rendering
function Dashboard({ isAdmin }: { isAdmin: boolean }) {
  return (
    <div>
      <h1>Dashboard</h1>
      {isAdmin && <AdminPanel />}
    </div>
  );
}
```

### Route-Based Code Splitting
```typescript
// Automatic code splitting with App Router
// Each page.tsx automatically creates a separate chunk

// app/encoding/base64/page.tsx
export default function Base64Page() {
  return <Base64Tool />;
}

// app/security/hash/page.tsx  
export default function HashPage() {
  return <HashTool />;
}
```

### Component-Based Splitting
```typescript
// Split by feature
const EncodingTools = dynamic(() => import('@/components/tools/EncodingTools'));
const SecurityTools = dynamic(() => import('@/components/tools/SecurityTools'));
const TextTools = dynamic(() => import('@/components/tools/TextTools'));

// Split by complexity
const SimpleCalculator = dynamic(() => import('./SimpleCalculator'));
const AdvancedCalculator = dynamic(() => import('./AdvancedCalculator'), {
  loading: () => <SimpleCalculator />
});
```

## ‚ö° React Optimization Patterns

### Memoization Strategies
```typescript
import { memo, useMemo, useCallback } from 'react';

// Component memoization
interface ToolCardProps {
  tool: Tool;
  onSelect: (id: string) => void;
  isFavorite: boolean;
}

const ToolCard = memo(({ tool, onSelect, isFavorite }: ToolCardProps) => {
  const handleSelect = useCallback(() => {
    onSelect(tool.id);
  }, [tool.id, onSelect]);

  return (
    <Card onClick={handleSelect}>
      <CardContent>
        <h3>{tool.name}</h3>
        <p>{tool.description}</p>
        {isFavorite && <Heart className="text-red-500" />}
      </CardContent>
    </Card>
  );
});

ToolCard.displayName = 'ToolCard';

// Parent component optimization
function ToolList({ tools, favorites }: { tools: Tool[]; favorites: string[] }) {
  const favoriteSet = useMemo(() => new Set(favorites), [favorites]);
  
  const handleToolSelect = useCallback((id: string) => {
    // Handle selection
  }, []);

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
      {tools.map(tool => (
        <ToolCard
          key={tool.id}
          tool={tool}
          onSelect={handleToolSelect}
          isFavorite={favoriteSet.has(tool.id)}
        />
      ))}
    </div>
  );
}
```

### State Optimization
```typescript
// Avoid unnecessary state updates
function SearchableList({ items }: { items: Item[] }) {
  const [searchTerm, setSearchTerm] = useState('');
  
  // Debounced search to avoid excessive filtering
  const debouncedSearchTerm = useMemo(() => {
    const timeoutId = setTimeout(() => searchTerm, 300);
    return () => clearTimeout(timeoutId);
  }, [searchTerm]);

  const filteredItems = useMemo(() => {
    if (!searchTerm) return items;
    return items.filter(item => 
      item.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [items, searchTerm]);

  return (
    <div>
      <input
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder="Search items..."
      />
      <div>
        {filteredItems.map(item => (
          <div key={item.id}>{item.name}</div>
        ))}
      </div>
    </div>
  );
}
```

### Context Optimization
```typescript
// Split contexts to avoid unnecessary re-renders
interface UserContextValue {
  user: User | null;
  setUser: (user: User | null) => void;
}

interface UIContextValue {
  sidebarOpen: boolean;
  setSidebarOpen: (open: boolean) => void;
}

// Separate contexts for different concerns
const UserContext = createContext<UserContextValue | null>(null);
const UIContext = createContext<UIContextValue | null>(null);

// Memoized context providers
function UserProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  
  const value = useMemo(() => ({
    user,
    setUser
  }), [user]);

  return (
    <UserContext.Provider value={value}>
      {children}
    </UserContext.Provider>
  );
}
```

## üñºÔ∏è Image Optimization

### Next.js Image Component
```typescript
import Image from 'next/image';

// Optimized image with proper sizing
function ToolIcon({ tool }: { tool: Tool }) {
  return (
    <Image
      src={tool.iconUrl}
      alt={`${tool.name} icon`}
      width={48}
      height={48}
      className="rounded-md"
      priority={tool.featured} // Load featured tools first
    />
  );
}

// Responsive images
function HeroImage() {
  return (
    <Image
      src="/hero-image.jpg"
      alt="Developer tools"
      fill
      className="object-cover"
      sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
      priority
    />
  );
}

// Lazy loaded gallery
function ImageGallery({ images }: { images: ImageData[] }) {
  return (
    <div className="grid grid-cols-3 gap-4">
      {images.map((image, index) => (
        <Image
          key={image.id}
          src={image.url}
          alt={image.alt}
          width={300}
          height={200}
          className="rounded-lg"
          loading={index < 6 ? 'eager' : 'lazy'} // Load first 6 eagerly
        />
      ))}
    </div>
  );
}
```

## üì¶ Bundle Optimization

### Tree Shaking
```typescript
// Good: Import only what you need
import { debounce } from 'lodash/debounce';
import { Button } from '@/components/ui/button';
import { formatDate } from 'date-fns/format';

// Bad: Importing entire libraries
// import _ from 'lodash';
// import * as dateFns from 'date-fns';

// Use dynamic imports for large utilities
async function processLargeData(data: unknown[]) {
  const { chunk } = await import('lodash/chunk');
  return chunk(data, 100);
}
```

### Bundle Analysis
```typescript
// Add to package.json scripts:
// "analyze": "ANALYZE=true npm run build"

// In next.config.ts
const withBundleAnalyzer = require('@next/bundle-analyzer')({
  enabled: process.env.ANALYZE === 'true',
});

module.exports = withBundleAnalyzer(nextConfig);
```

### Dependency Optimization
```typescript
// Replace heavy libraries with lighter alternatives
// Instead of moment.js (67kB), use day.js (2kB)
import dayjs from 'dayjs';

// Instead of full Lodash, use individual functions
import debounce from 'lodash.debounce';
import throttle from 'lodash.throttle';

// Use native APIs when possible
const formatCurrency = (amount: number) => {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD'
  }).format(amount);
};
```

## üîÑ Caching Strategies

### Next.js Caching
```typescript
// Static generation with revalidation
export async function generateStaticParams() {
  const tools = await getTools();
  return tools.map(tool => ({ id: tool.id }));
}

// Page with ISR (Incremental Static Regeneration)
export const revalidate = 3600; // Revalidate every hour

// API route caching
export async function GET() {
  const tools = await getTools();
  
  return NextResponse.json(tools, {
    headers: {
      'Cache-Control': 'public, s-maxage=3600, stale-while-revalidate=86400'
    }
  });
}
```

### Client-Side Caching
```typescript
// React Query for API caching
function useTools() {
  return useQuery({
    queryKey: ['tools'],
    queryFn: fetchTools,
    staleTime: 5 * 60 * 1000, // 5 minutes
    cacheTime: 10 * 60 * 1000, // 10 minutes
  });
}

// Local storage caching
const CACHE_KEY = 'user-preferences';
const CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours

function usePersistedState<T>(key: string, defaultValue: T) {
  const [state, setState] = useState<T>(() => {
    try {
      const cached = localStorage.getItem(key);
      if (cached) {
        const { value, timestamp } = JSON.parse(cached);
        if (Date.now() - timestamp < CACHE_DURATION) {
          return value;
        }
      }
    } catch {
      // Ignore cache errors
    }
    return defaultValue;
  });

  const setValue = useCallback((value: T) => {
    setState(value);
    try {
      localStorage.setItem(key, JSON.stringify({
        value,
        timestamp: Date.now()
      }));
    } catch {
      // Ignore storage errors
    }
  }, [key]);

  return [state, setValue] as const;
}
```

## üé≠ Loading States & Suspense

### Suspense Boundaries
```typescript
import { Suspense } from 'react';

// Loading fallbacks
function ToolListSkeleton() {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
      {Array.from({ length: 9 }).map((_, i) => (
        <div key={i} className="animate-pulse">
          <div className="bg-muted h-32 rounded-lg" />
        </div>
      ))}
    </div>
  );
}

// Suspense wrapper
function ToolsPage() {
  return (
    <div>
      <h1>Developer Tools</h1>
      <Suspense fallback={<ToolListSkeleton />}>
        <ToolList />
      </Suspense>
    </div>
  );
}

// Nested suspense for granular loading
function Dashboard() {
  return (
    <div className="space-y-6">
      <Suspense fallback={<div className="h-20 bg-muted animate-pulse rounded" />}>
        <StatsWidget />
      </Suspense>
      
      <Suspense fallback={<ToolListSkeleton />}>
        <RecentTools />
      </Suspense>
      
      <Suspense fallback={<div className="h-64 bg-muted animate-pulse rounded" />}>
        <ActivityChart />
      </Suspense>
    </div>
  );
}
```

## üìä Performance Monitoring

### Core Web Vitals
```typescript
// Web Vitals reporting
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

function sendToAnalytics(metric: any) {
  // Send to your analytics service
  console.log(metric);
}

// Measure all vitals
getCLS(sendToAnalytics);
getFID(sendToAnalytics);
getFCP(sendToAnalytics);
getLCP(sendToAnalytics);
getTTFB(sendToAnalytics);

// Custom performance tracking
function usePerformanceMonitor() {
  useEffect(() => {
    const observer = new PerformanceObserver((list) => {
      list.getEntries().forEach((entry) => {
        if (entry.entryType === 'navigation') {
          console.log('Page load time:', entry.duration);
        }
      });
    });
    
    observer.observe({ entryTypes: ['navigation'] });
    
    return () => observer.disconnect();
  }, []);
}
```

### Runtime Performance
```typescript
// Performance profiling in development
function ProfiledComponent({ children }: { children: React.ReactNode }) {
  useEffect(() => {
    if (process.env.NODE_ENV === 'development') {
      const start = performance.now();
      
      return () => {
        const end = performance.now();
        console.log(`Component render time: ${end - start}ms`);
      };
    }
  });

  return <>{children}</>;
}

// Memory usage monitoring
function useMemoryMonitor() {
  useEffect(() => {
    const interval = setInterval(() => {
      if ('memory' in performance) {
        const memory = (performance as any).memory;
        console.log({
          usedJSHeapSize: memory.usedJSHeapSize,
          totalJSHeapSize: memory.totalJSHeapSize,
          jsHeapSizeLimit: memory.jsHeapSizeLimit
        });
      }
    }, 10000); // Check every 10 seconds

    return () => clearInterval(interval);
  }, []);
}
```

## üîß Development Tools

### Performance Debugging
```typescript
// React DevTools Profiler integration
import { Profiler } from 'react';

function onRenderCallback(
  id: string,
  phase: 'mount' | 'update',
  actualDuration: number,
  baseDuration: number,
  startTime: number,
  commitTime: number
) {
  console.log('Profiler:', {
    id,
    phase,
    actualDuration,
    baseDuration,
    startTime,
    commitTime
  });
}

function App() {
  return (
    <Profiler id="App" onRender={onRenderCallback}>
      <Router>
        <Routes>
          {/* Your routes */}
        </Routes>
      </Router>
    </Profiler>
  );
}
```

Remember: **Performance is a feature** - Optimize proactively rather than reactively. Regular performance audits and monitoring help maintain a fast, responsive user experience. Always measure before and after optimizations to ensure they provide real benefits.
